name: test-pipeline

# 向 main 分支创建或更新 PR 时触发
on:
  pull_request_target:
    types:
      - opened
      - synchronize # PR创建或代码更新时触发
    branches:
      - main
  # 允许手动触发（UI或API）
  workflow_dispatch:
    # 带输入参数
    inputs:
      environment:
        description: 'Deploy target (prod/uat)'
        required: true
        default: 'uat'
        type: choice
        options:
          - prod
          - uat
      debug_mode:
        description: 'Enable debug logs?'
        required: false
        type: boolean

jobs:
  # 构建
  build:
    runs-on: ubuntu-latest
    # 输出变量用于第二个job
    outputs:
      version: ${{ steps.build-and-publish.outputs.version }}
    steps:
      # 检出代码
      - name: checkout-code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }} # 指定切换到PR提交的源分支

      # 安装JDK21
      - name: setup-java
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin' # 使用 Temurin 产商的 JDK 版本

      # 配置Maven仓库缓存，避免每次构建时都重新下载依赖
      - name: cache-local-maven-repository
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: |
            ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      # 构建并发布到仓库
      - id: build-and-publish
        name: build-and-publish
        env:
          IS_RELEASE: false
          MAVEN_USERNAME: ${{ secrets.NEXUS_USERNAME }}
          MAVEN_PASSWORD: ${{ secrets.NEXUS_PASSWORD }}
          SERVICE_NAME: ${{ vars.SERVICE_NAME }}
        run: |
          bash .github/workflows/build/buildAndPublish.sh

  # 部署
  deploy:
    # 需要 build 执行完后才执行，否则 job 是并行执行的
    needs: build
    runs-on: debian-hk-claw-2c2g
    env:
      DEPLOY_PATH: ${{ vars.DEPLOY_PATH }}
      SERVICE_NAME: ${{ vars.SERVICE_NAME }}
      SERVICE_PORT: ${{ vars.SERVICE_PORT }}
      ARTIFACT_ID: ${{ vars.ARTIFACT_ID }}
      NEXUS_HOST: ${{ vars.NEXUS_HOST }}
      GROUP_ID: ${{ vars.GROUP_ID }}
      VERSION: ${{ needs.build.outputs.version }}
      MAVEN_USERNAME: ${{ secrets.NEXUS_USERNAME }}
      MAVEN_PASSWORD: ${{ secrets.NEXUS_PASSWORD }}
    steps:
      # 使用systemd管理的Java服务，就不需要这个步骤了
      #      - name: stop
      #        run: |
      #          echo "0.停止相关进程..."
      #          PID=$(ps -ef | grep $ARTIFACT_ID-$VERSION.jar | grep -v grep | awk '{ print $2 }')
      #          if [ -n "$PID" ]; then
      #              echo "Killing process with PID $PID"
      #              kill -9 $PID
      #          fi
      - name: uninstall
        run: |
          echo "0.删除对应文件..."
          find /opt/apps/TestService/ \( -name '*.jar' -o -name 'maven-metadata.xml' \) -delete
      - name: install
        run: |
          #  检查部署目录是否存在，不存在则创建
          echo "0.检查部署目录是否存在，不存在则创建..."
          if [ ! -d "$DEPLOY_PATH/$SERVICE_NAME" ]; then
              echo "部署目录不存在，正在创建: $DEPLOY_PATH/$SERVICE_NAME"
              mkdir -p "$DEPLOY_PATH/$SERVICE_NAME"
              chown appuser:appgroup -R "$DEPLOY_PATH/$SERVICE_NAME"
          else
              echo "部署目录已存在: $DEPLOY_PATH/$SERVICE_NAME"
          fi
          
          ## 进入部署目录
          cd "$DEPLOY_PATH/$SERVICE_NAME" || { echo "无法进入部署目录"; exit 1; }
          
          # 从私有仓库拉取安装包
          echo "等待maven-metadata.xml更新 10s..." 
          sleep 10 
          echo "1.下载maven-metadata.xml..."
          METADATA_URL="$NEXUS_HOST/repository/maven-snapshots/$GROUP_ID/$ARTIFACT_ID/$VERSION/maven-metadata.xml"
          if wget --user=$MAVEN_USERNAME --password=$MAVEN_PASSWORD "$METADATA_URL" -O maven-metadata.xml; then
                echo "maven-metadata.xml拉取成功: maven-metadata.xml"
            else
                echo "maven-metadata.xml拉取失败"
                exit 1
            fi
          echo "2.正在从maven-metadata.xml解析出snapshotVersion字段并拼接安装包下载URL..."
          SNAPSHOT_VERSION=$(grep '<value>' maven-metadata.xml | sed 's/<[^>]*>//g' | head -n1 | tr -d ' \t')
          DOWNLOAD_URL="$NEXUS_HOST/repository/maven-snapshots/$GROUP_ID/$ARTIFACT_ID/$VERSION/$ARTIFACT_ID-$SNAPSHOT_VERSION.jar"
          
          echo "3.正在从私有仓库拉取安装包..."
          if wget --user=$MAVEN_USERNAME --password=$MAVEN_PASSWORD "$DOWNLOAD_URL" -O "$ARTIFACT_ID-$VERSION.jar"; then
              echo "安装包拉取成功: $ARTIFACT_ID-$VERSION.jar"
          else
              echo "安装包拉取失败"
              exit 1
          fi   
          chown appuser:appgroup -R "$DEPLOY_PATH/$SERVICE_NAME"
          echo "安装完成"
      - name: start
        run: |
          echo "0.启动程序..."
          cat << EOF | sudo tee /etc/systemd/system/$ARTIFACT_ID.service
          [Unit]
          Description=${SERVICE_NAME}
          After=network.target

          [Service]
          ExecStart=${JAVA_HOME}/bin/java \
                    -jar $DEPLOY_PATH/$SERVICE_NAME/$ARTIFACT_ID-$VERSION.jar \
                    --spring.profiles.active=uat --server.port=${SERVER_PORT}
          Restart=on-failure
          User=appuser
          Group=appgroup

          [Install]
          WantedBy=multi-user.target
          EOF

          sudo systemctl daemon-reload
          sudo systemctl enable $ARTIFACT_ID.service
          sudo systemctl restart $ARTIFACT_ID.service
      - name: check
        run: |
          echo "0.健康检查..."
          status_check() {
            echo `curl -I -m 10 -o /dev/null -s -w %{http_code} "http://localhost:${SERVICE_PORT}/api/v1/test/healthcheck"`
          }

          # 设置最大尝试次数
          max_attempts=30
          attempts=0

          result=$(status_check)
          until [ "200"x = "$result"x ] || [ $attempts -ge $max_attempts ]
          do
            result=$(status_check)
            ((attempts++))
            # sleep 2
          done

          # 检查是否达到最大尝试次数
          if [ $attempts -ge $max_attempts ]; then
            echo "Timeout reached, status is not 200"
            exit 1 # 返回错误状态码
          else
            echo "Status is 200"
            exit 0 # 返回成功状态码
          fi
